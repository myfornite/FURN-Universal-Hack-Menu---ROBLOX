local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "FURN Universal Hub",
	Icon = "leaf", -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "Loading...",
	LoadingSubtitle = "Please wait.",
	Theme = "Amethyst", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = false,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "Big Hub"
	},

	Discord = {
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Untitled",
		Subtitle = "Key System",
		Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})

local MainTab = Window:CreateTab("Main", nil) -- Title, Image

player = game.Players.LocalPlayer

local SetWalkSpeed = game.StarterPlayer.CharacterWalkSpeed
local ForceWalkSpeed = false
local wsdelay, wscooldown = false, 0.3

local function setVars()
	char = player.Character
	hum = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")
	head = char:WaitForChild("Head")
	cam = game.Workspace.CurrentCamera
	hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if wsdelay then return end
		if not ForceWalkSpeed then return end
		if not hum then return end
		wsdelay = false
		hum.WalkSpeed = SetWalkSpeed
		task.wait(wscooldown)
		wsdelay = false
	end)
end
setVars()

local RS = game.ReplicatedStorage
local uis = game.UserInputService
local mouse = player:GetMouse()
local Camera = game.Workspace.CurrentCamera

player.CharacterAdded:Connect(function()
	setVars()
	wsdelay = false
	if ForceWalkSpeed and hum then
		hum.WalkSpeed = SetWalkSpeed
	end
	ToggleFlight:Set(false)
end)

for i, thing in RS:GetDescendants() do
	if thing:IsA("ColorGradingEffect") then thing:Destroy() end
end

Status =  Instance.new("ColorGradingEffect", RS)
Status.Name = "Status"..math.random(10000,99999)
StatusFlagType = "BoolValue"

local CharacterSection = MainTab:CreateSection("Character")

local ToggleForceWalkSpeed = MainTab:CreateToggle({
	Name = "Force Walk Speed",
	CurrentValue = ForceWalkSpeed,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		ForceWalkSpeed = Value
		if ForceWalkSpeed and hum then
			hum.WalkSpeed = SetWalkSpeed
		end
	end,
})

local SliderWalkSpeed = MainTab:CreateSlider({
	Name = "Set Walk Speed",
	Range = {SetWalkSpeed, 250},
	Increment = 1,
	Suffix = "",
	CurrentValue = SetWalkSpeed,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		if not hum then return end
		SetWalkSpeed = tonumber(Value)
		hum.WalkSpeed = SetWalkSpeed
	end,
})

local InputWalkSpeed = MainTab:CreateInput({
	Name = "Set Walk Speed",
	CurrentValue = SetWalkSpeed,
	PlaceholderText = "number",
	RemoveTextAfterFocusLost = true,
	Flag = "Input1",
	Callback = function(Text)
		-- The function that takes place when the input is changed
		-- The variable (Text) is a string for the value in the text box
		SetWalkSpeed = tonumber(Text)
		if not hum then return end
		hum.WalkSpeed = SetWalkSpeed
	end,
})

local DefaultGravity = game.Workspace.Gravity

local SliderGravity = MainTab:CreateSlider({
	Name = "Gravity",
	Range = {0, 500},
	Increment = 5,
	Suffix = "",
	CurrentValue = DefaultGravity,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		game.Workspace.Gravity = Value
	end,
})

local ButtonFlingSelf = MainTab:CreateButton({
	Name = "Fling Self",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not hum then return end
		if not hrp then return end
		local n1 = 1000
		hum:ChangeState(Enum.HumanoidStateType.Physics)
		task.wait(0.12)
		hrp.Velocity = Vector3.new(n1,n1,n1)
	end,
})

local TeleportationSection = MainTab:CreateSection("Teleportion")

local TeleportationEnabled = false
local InstantTransmissionEnabled = false
local SelectedPlr = ""

local ToggleTeleportation = MainTab:CreateToggle({
	Name = "Teleportation (RMB + LBM)",
	CurrentValue = TeleportationEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		TeleportationEnabled = Value
	end,
})

local ToggleInstantTransmission = MainTab:CreateToggle({
	Name = "Instant Transmission (T)",
	CurrentValue = InstantTransmissionEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		InstantTransmissionEnabled = Value
	end,
})

local PlayerOptionsTable = {"Select"}

local DropdownTeleportToPlayer = MainTab:CreateDropdown({
	Name = "Select Player",
	Options = PlayerOptionsTable,
	CurrentOption = {"Select"},
	MultipleOptions = false,
	Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Options)
		-- The function that takes place when the selected option is changed
		-- The variable (Options) is a table of strings for the current selected options
		SelectedPlr = tostring(Options[1])
	end,
})

function ResetTpToPlrList()
	PlayerOptionsTable = {"Select"}
	for i, thing in game.Players:GetChildren() do
		if not thing:IsA("Player") then continue end
		table.insert(PlayerOptionsTable, tostring(thing.DisplayName).." (@"..tostring(thing.Name)..")")
	end
	DropdownTeleportToPlayer:Refresh(PlayerOptionsTable) -- The new list of options available.
end
ResetTpToPlrList()

game.Players.PlayerAdded:Connect(function(NewPlr)
	ResetTpToPlrList()
end)

local ButtonTeleportToPlayer = MainTab:CreateButton({
	Name = "Teleport To Player",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not SelectedPlr then return end
		local GetSelectedPlr = game.Players:FindFirstChild(string.sub(string.split(SelectedPlr, "@")[2], 1, -2))
		if not GetSelectedPlr then return end
		local SelectedPlrCharacter = GetSelectedPlr.Character
		if not SelectedPlrCharacter then return end
		local SelectedPlrHumanoidRoot = SelectedPlrCharacter:FindFirstChild("HumanoidRootPart")
		if not SelectedPlrHumanoidRoot then return end
		if not char or not hrp then return end
		local pos = SelectedPlrHumanoidRoot.Position
		hrp:PivotTo(CFrame.new(pos))
		TpSound()
	end,
})

local MovementSection = MainTab:CreateSection("Movement")

function TpSound()
	if not char or not hrp then return end
	local sound = Instance.new("Sound")
	sound.Volume = 0.25
	sound.SoundId = "rbxassetid://5066021887"
	sound.PlayOnRemove = true
	sound.Parent = hrp
	sound:Destroy()
end

local UnlockMouseGuiName = "UnlockMouseTemp"

uis.InputBegan:Connect(function(input, typing)
	if typing then return end
	if not char then return end
	if not hrp then return end

	if input.KeyCode == Enum.KeyCode.V and Status then
		local tempGui = Instance.new("ScreenGui", player.PlayerGui)
		tempGui.Name = UnlockMouseGuiName
		tempGui.Enabled = true
		tempGui.ResetOnSpawn = false
		local tempButtonModal = Instance.new("TextButton", tempGui)
		tempButtonModal.Visible = true
		tempButtonModal.BackgroundTransparency = 1
		tempButtonModal.TextTransparency = 1
		tempButtonModal.Text = ""
		tempButtonModal.Modal = true
	end

	if uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) and input.UserInputType == Enum.UserInputType.MouseButton1 and TeleportationEnabled then
		local pos = mouse.Hit
		hrp:PivotTo(pos)
		TpSound()
	end

	if input.KeyCode == Enum.KeyCode.T and InstantTransmissionEnabled then
		local closestPlayer = nil
		local closestDistance = 300

		for _, plr in ipairs(game.Players:GetPlayers()) do
			if plr ~= player and (plr.Team ~= player.Team or #game.Teams:GetChildren() < 2) and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
				local distance = (hrp.Position - plr.Character.HumanoidRootPart.Position).Magnitude
				if distance < closestDistance then
					closestDistance = distance
					closestPlayer = plr
				end
			end
		end
		local targetPlr = closestPlayer
		if targetPlr and targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart") then
			local targetHrp = targetPlr.Character.HumanoidRootPart
			local direction = targetHrp.CFrame.LookVector * -2 -- Moves behind
			hrp.CFrame = targetHrp.CFrame + direction
			cam.CFrame = CFrame.lookAt(cam.CFrame.Position, targetHrp.Position)
			TpSound()
		end
	end

	if input.KeyCode == Enum.KeyCode.Space then
		local bool = Status:FindFirstChild("AirJump")
		if not bool then return end
		local savedHeight = nil
		local IsJumpPwr = hum.UseJumpPower
		local dfJump = nil
		if IsJumpPwr then
			dfJump = game.StarterPlayer.CharacterJumpPower
			savedHeight = hum.JumpPower
			hum.JumpPower = dfJump
			task.delay(0.05, function()
				hum.JumpPower = dfJump
			end)
		else
			dfJump = game.StarterPlayer.CharacterJumpHeight
			savedHeight = hum.JumpHeight
			hum.JumpHeight = dfJump
			task.delay(0.05, function()
				hum.JumpHeight = dfJump
			end)
		end
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
		task.wait(0.1)
		if IsJumpPwr then
			hum.JumpPower = savedHeight or dfJump
		else
			hum.JumpHeight = savedHeight or dfJump
		end
	end
end)

uis.InputEnded:Connect(function(input, typing)
	if input.KeyCode == Enum.KeyCode.V and Status then
		local tempGui = player.PlayerGui:FindFirstChild(UnlockMouseGuiName)
		if tempGui then tempGui:Destroy() end
	end
end)

local flying = false
local flyspeed = 50

local bodyVelocity = nil

local bodyGyro = nil

local moveDirection = Vector3.new(0, 0, 0)

local function updateFlyDirection()
	if flying then
		if not bodyVelocity then
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "BodyVelocityOrSomething"
			bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			bodyVelocity.Parent = hrp
		end
		if not bodyGyro then
			bodyGyro = Instance.new("BodyGyro")
			bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
			bodyGyro.P = 3000
			bodyGyro.Parent = hrp
		end
		local camera = workspace.CurrentCamera
		local direction = camera.CFrame.LookVector * moveDirection.Z + camera.CFrame.RightVector * moveDirection.X
		bodyVelocity.Velocity = direction * flyspeed + Vector3.new(0, moveDirection.Y * flyspeed, 0)
		bodyGyro.CFrame = camera.CFrame
	end
end

local function toggleFly(set)
	if set == nil then
		flying = not flying
	else
		flying = set
	end
	if flying then
		game["Run Service"].RenderStepped:Connect(updateFlyDirection)
	else
		if bodyVelocity then bodyVelocity:Destroy() end
		if bodyGyro then bodyGyro:Destroy() end
		bodyVelocity = nil
		bodyGyro = nil
	end
end

ToggleFlight = MainTab:CreateToggle({
	Name = "Flight",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		toggleFly(Value)
	end,
})

local InputFlightSpeed = MainTab:CreateInput({
	Name = "Fly Speed",
	CurrentValue = flyspeed,
	PlaceholderText = "number",
	RemoveTextAfterFocusLost = true,
	Flag = "Input1",
	Callback = function(Text)
		-- The function that takes place when the input is changed
		-- The variable (Text) is a string for the value in the text box
		flyspeed = tonumber(Text)
	end,
})

local ToggleAirJump = MainTab:CreateToggle({
	Name = "Air Jump",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		if char and not Value then
			local bool = Status:FindFirstChild("AirJump")
			if bool then bool:Destroy() end
		end
		if not Value then return end
		if not char then return end
		local NewFlagVar = Instance.new(StatusFlagType, Status)
		NewFlagVar.Name = "AirJump"
	end,
})

local tp16 = uis.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.W then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, 1)
	elseif input.KeyCode == Enum.KeyCode.S then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, -1)
	elseif input.KeyCode == Enum.KeyCode.A then
		moveDirection = Vector3.new(-1, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.D then
		moveDirection = Vector3.new(1, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.E then
		moveDirection = Vector3.new(moveDirection.X, 1, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.Q then
		moveDirection = Vector3.new(moveDirection.X, -1, moveDirection.Z)
	end
end)

local tp26 = uis.InputEnded:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, 0)
	elseif input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.D then
		moveDirection = Vector3.new(0, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
		moveDirection = Vector3.new(moveDirection.X, 0, moveDirection.Z)
	end
end)

local CameraSection = MainTab:CreateSection("Camera")

local AimAssistSpeed = 100  -- Smoothness for aim assist; lower values = slower movement
local AimRange = 100  -- Distance in pixels within which the aim-assist will trigger

-- Function to check if the player is in first-person
local function isFirstPerson()
	return (Camera.CFrame.Position - player.Character.Head.Position).Magnitude < 1.5 or uis.MouseBehavior == Enum.MouseBehavior.LockCenter  -- Close to player's head
end
local function aimbotkeydown()
	return aimbotToggled and aimbotenabled
end

local plrDBaim = false
local plrCDaim = 0

-- Function to find the nearest humanoid to the mouse that is visible (no walls)
local function getNearestHumanoidToMouse()
	local nearestHumanoid = nil
	local shortestDistance = (AimRange)*6

	for _, object in pairs(workspace:GetDescendants()) do
		if object:IsA("Humanoid") and object.Parent:FindFirstChild("HumanoidRootPart") then
			if object.Parent ~= player.Character then
				local humanoidRootPart = object.Parent:FindFirstChild("HumanoidRootPart")
				local screenPosition, onScreen = Camera:WorldToScreenPoint(humanoidRootPart.Position)

				if onScreen then
					local distanceFromMouse = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPosition.X, screenPosition.Y)).magnitude

					if distanceFromMouse < shortestDistance then
						-- Set up raycast parameters to ignore the player's character and their parts

						local raycastParams = RaycastParams.new()
						raycastParams.FilterType = Enum.RaycastFilterType.Exclude
						local table1 = {player.Character}
						--[[
						for i, part in game.Workspace:GetDescendants() do
							if not (part.Parent:FindFirstChildOfClass("Humanoid")) then
								if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("UnionOperation") then
									table.insert(table1, part)
								end
							end
							task.wait()
						end
						--]]
						raycastParams.FilterDescendantsInstances = table1

						-- Perform raycast to check for obstacles between the camera and the humanoid's root part
						local rayDirection = (humanoidRootPart.Position - Camera.CFrame.Position).unit * 1000
						local raycastResult = workspace:Raycast(Camera.CFrame.Position, rayDirection, raycastParams)

						-- If ray hits the humanoid's root part, there is no wall in the way
						if raycastResult and raycastResult.Instance:IsDescendantOf(object.Parent) then
							local plr = game.Players:GetPlayerFromCharacter(object.Parent)
							if plr then
								local plrhum = plr.Character:FindFirstChildOfClass("Humanoid")
								local plrhrp = plr.Character:FindFirstChild("HumanoidRootPart")
								if (plr.Team == player.Team and #game.Teams:GetChildren() > 1) then
									return
								end
								if not plrhum then return end
								if not plrhrp then return end
								if plrhum and plrhum.Health <= 0 then return end
								if plrhum and plrhum.Health >= 101 then return end
							end
							nearestHumanoid = object
							shortestDistance = distanceFromMouse
						end
					end
				end
			end
		end
	end

	return nearestHumanoid
end

game["Run Service"].RenderStepped:Connect(function(delta)
	if aimbotkeydown() and isFirstPerson() and not plrDBaim then  -- Only work in first-person mode
		local targetHumanoid = getNearestHumanoidToMouse()

		if targetHumanoid and targetHumanoid.Parent:FindFirstChild('HumanoidRootPart') then
			plrDBaim = true
			local head1 = targetHumanoid.Parent:FindFirstChild('Head')
			if not head1 then return end
			local targetPosition = head1.Position
			Camera = game.Workspace.CurrentCamera
			local currentPosition = Camera.CFrame.Position
			local direction = (targetPosition - currentPosition).unit

			-- Smoothly adjust the camera's CFrame to look at the target
			local newCFrame = CFrame.new(currentPosition, currentPosition + direction)
			if AimAssistSpeed <= 0 then
				Camera.CFrame = newCFrame
			else
				Camera.CFrame = Camera.CFrame:Lerp(newCFrame, ((AimAssistSpeed * 20)/100)*delta)
			end
			task.wait(plrCDaim)
			plrDBaim = false
		end
	end
end)

aimbotToggled = false
aimbotenabled = false
aimbotkey = Enum.UserInputType.MouseButton2
local tp1234 = uis.InputBegan:Connect(function(input, typing)
	if input.UserInputType == aimbotkey and aimbotToggled then
		aimbotenabled = true
	end
end)
local tp2234 = uis.InputEnded:Connect(function(input, typing)
	if input.UserInputType == aimbotkey then
		aimbotenabled = false
	end
end)

ToggleAimBot = MainTab:CreateToggle({
	Name = "Aim bot- i mean assist (RMB)",
	CurrentValue = aimbotToggled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		aimbotToggled = Value
	end,
})

local SliderAimBotSpeed = MainTab:CreateSlider({
	Name = "Aim Bot Speed (0 for instant snapping)",
	Range = {0, 250},
	Increment = 10,
	Suffix = "",
	CurrentValue = AimAssistSpeed,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		AimAssistSpeed = tonumber(Value) or 0
	end,
})

local SliderAimBotRange = MainTab:CreateSlider({
	Name = "Aim Bot Range (100 is your whole screen)",
	Range = {10, 100},
	Increment = 10,
	Suffix = "",
	CurrentValue = AimRange,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		AimAssistSpeed = tonumber(Value) or 100
	end,
})

local BuildABoatForTreasureTab = Window:CreateTab("Build A Boat For Treasure", nil) -- Title, Image

local BabAutoWinEnabled = false

local ToggleBabAutoWin = BuildABoatForTreasureTab:CreateToggle({
	Name = "Auto Farm",
	CurrentValue = InstantTransmissionEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		BabAutoWinEnabled = Value
		task.spawn(function()
			while BabAutoWinEnabled do
				hrp.Velocity = Vector3.new(0,0,0)
				task.wait(0.03)
			end
		end)
		while BabAutoWinEnabled do
			task.wait(0.5)
			if not hrp then continue end
			hrp.Anchored = false
			local SmoothTweenEasingStyle = Enum.EasingStyle.Linear
			local InitialPos = game.TweenService:Create(hrp, TweenInfo.new(1, SmoothTweenEasingStyle), {CFrame = CFrame.new(-51.4020881652832, 42.1522228717803955, 232.0143127441406, 1, 2.8233428e-08, 0.000197172689, -2.82372294e-08, 1, 1.92742942e-08, -0.000197172689, -1.92798613e-08, 1)})
			InitialPos:Play()
			InitialPos.Completed:Wait()
			local FlyToWaterFall = game.TweenService:Create(hrp, TweenInfo.new(23, SmoothTweenEasingStyle), {CFrame = CFrame.new(-20.47932815551758, 65.726470947265625, 8652.3564453125, -0.322770327, 4.80723372e-08, 0.946477294, -2.44336444e-08, 1, -5.91232272e-08, -0.946477294, -4.22091126e-08, -0.322770327)})
			FlyToWaterFall:Play()
			FlyToWaterFall.Completed:Wait()
			local FlyDownWaterFall = game.TweenService:Create(hrp, TweenInfo.new(1.2, SmoothTweenEasingStyle), {CFrame = CFrame.new(-47.588069915771484, -336.2562561035156, 8662.7421875, -0.992341876, -1.69527556e-08, -0.123521589, -2.45594425e-08, 1, 6.00591932e-08, 0.123521589, 6.26328784e-08, -0.992341876)})
			FlyDownWaterFall:Play()
			FlyDownWaterFall.Completed:Wait()
			local FlyToTreasure = game.TweenService:Create(hrp, TweenInfo.new(2.5, SmoothTweenEasingStyle), {CFrame = CFrame.new(-55.87642288208008, -360.52899169921875, 9492.6767578125, -0.322770327, 4.80723372e-08, 0.946477294, -2.44336444e-08, 1, -5.91232272e-08, -0.946477294, -4.22091126e-08, -0.322770327)})
			FlyToTreasure:Play()
			FlyToTreasure.Completed:Wait()
			hrp.Anchored = true
			task.wait(1.2)
			local FlyToTreasure2 = game.TweenService:Create(hrp, TweenInfo.new(3, SmoothTweenEasingStyle), {CFrame = CFrame.new(-55.87642288208008, -360.52899169921875, 9493.6767578125, -0.866842806, -2.4441368e-08, -0.498581529, -2.98235392e-08, 1, 2.82993073e-09, 0.498581529, 1.732257e-08, -0.866842806)})
			FlyToTreasure2:Play()
			FlyToTreasure2.Completed:Wait()
			task.wait(2)
			hrp.Anchored = false
			task.wait(18)
		end
	end,
})

local TheStrongestBattlegroundsTab = Window:CreateTab("The Strongest Battlegrounds", nil) -- Title, Image

local SgbAnimsSection = TheStrongestBattlegroundsTab:CreateSection("Animations")

task.wait(2)

local FakeSaitamaUltAnim = Instance.new("Animation")
FakeSaitamaUltAnim.AnimationId = "rbxassetid://12447707844"
FakeSaitamaUltAnim = hum:LoadAnimation(FakeSaitamaUltAnim)
FakeSaitamaUltAnim.Looped = false
player.CharacterAdded:Connect(function()
	local FakeSaitamaUltAnim = Instance.new("Animation")
	FakeSaitamaUltAnim.AnimationId = "rbxassetid://12447707844"
	FakeSaitamaUltAnim = hum:LoadAnimation(FakeSaitamaUltAnim)
	FakeSaitamaUltAnim.Looped = false
end)
local ToggleFakeSaitamaUltAnimSgb = TheStrongestBattlegroundsTab:CreateToggle({
	Name = "Fake Saitama Ultimate",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		if Value then
			FakeSaitamaUltAnim:Play()
		else
			FakeSaitamaUltAnim:Stop()
		end
	end,
})
FakeSaitamaUltAnim.Ended:Connect(function()
	ToggleFakeSaitamaUltAnimSgb:Set(false)
end)

local FakeOmniAnim = Instance.new("Animation")
FakeOmniAnim.AnimationId = "rbxassetid://13927612951"
FakeOmniAnim = hum:LoadAnimation(FakeOmniAnim)
FakeOmniAnim.Looped = false
player.CharacterAdded:Connect(function()
	local FakeOmniAnim = Instance.new("Animation")
	FakeOmniAnim.AnimationId = "rbxassetid://13927612951"
	FakeOmniAnim = hum:LoadAnimation(FakeOmniAnim)
	FakeOmniAnim.Looped = false
end)
local FakeOmniAnim2 = Instance.new("Animation")
FakeOmniAnim2.AnimationId = "rbxassetid://13891242085"
FakeOmniAnim2 = hum:LoadAnimation(FakeOmniAnim2)
FakeOmniAnim2.Looped = false
player.CharacterAdded:Connect(function()
	local FakeOmniAnim2 = Instance.new("Animation")
	FakeOmniAnim2.AnimationId = "rbxassetid://13891242085"
	FakeOmniAnim2 = hum:LoadAnimation(FakeOmniAnim2)
	FakeOmniAnim2.Looped = false
end)
local ToggleFakeOmniAnimSgb = TheStrongestBattlegroundsTab:CreateToggle({
	Name = "Fake Omni Directional Punch",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		if Value then
			FakeOmniAnim:Play()
			FakeOmniAnim2:Stop()
		else
			FakeOmniAnim:Stop()
			FakeOmniAnim2:Stop()
		end
	end,
})
FakeOmniAnim.Ended:Connect(function()
	FakeOmniAnim2:Play(0)
end)
FakeOmniAnim2.Ended:Connect(function()
	ToggleFakeOmniAnimSgb:Set(false)
end)

local UFWuserAnim = Instance.new("Animation")
UFWuserAnim.AnimationId = "rbxassetid://77727115892579"
UFWuserAnim = hum:LoadAnimation(UFWuserAnim)
UFWuserAnim.Looped = false
player.CharacterAdded:Connect(function()
	local UFWuserAnim = Instance.new("Animation")
	UFWuserAnim.AnimationId = "rbxassetid://77727115892579"
	UFWuserAnim = hum:LoadAnimation(UFWuserAnim)
	UFWuserAnim.Looped = false
end)
local ToggleUFWanimSgb = TheStrongestBattlegroundsTab:CreateToggle({
	Name = "Ultimate Flex Works",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		if Value then
			UFWuserAnim:Play()
		else
			UFWuserAnim:Stop()
		end
	end,
})
UFWuserAnim.Ended:Connect(function()
	ToggleUFWanimSgb:Set(false)
end)
