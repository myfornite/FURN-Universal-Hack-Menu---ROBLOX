local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
	Name = "FURN UniHub",
	Icon = "leaf", -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
	LoadingTitle = "Loading...",
	LoadingSubtitle = "Please wait.",
	Theme = "Amethyst", -- Check https://docs.sirius.menu/rayfield/configuration/themes

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

	ConfigurationSaving = {
		Enabled = false,
		FolderName = nil, -- Create a custom folder for your hub/game
		FileName = "Big Hub"
	},

	Discord = {
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = true -- Set this to false to make them join the discord every time they load it up
	},

	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "Untitled",
		Subtitle = "Key System",
		Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
		FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
	}
})

local MainTab = Window:CreateTab("Main Tools", "user-round") -- Title, Image

player = game.Players.LocalPlayer

local SetWalkSpeed = game.StarterPlayer.CharacterWalkSpeed
local ForceWalkSpeed = false
local wsdelay, wscooldown = false, 0.3

local function setVars()
	char = player.Character
	hum = char:WaitForChild("Humanoid")
	hrp = char:WaitForChild("HumanoidRootPart")
	head = char:WaitForChild("Head")
	cam = game.Workspace.CurrentCamera
	hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if wsdelay then return end
		if not ForceWalkSpeed then return end
		if not hum then return end
		wsdelay = false
		hum.WalkSpeed = SetWalkSpeed
		task.wait(wscooldown)
		wsdelay = false
	end)
end
setVars()

local RS = game.ReplicatedStorage
local uis = game.UserInputService
local mouse = player:GetMouse()
local Camera = game.Workspace.CurrentCamera

player.CharacterAdded:Connect(function()
	setVars()
	wsdelay = false
	if ForceWalkSpeed and hum then
		hum.WalkSpeed = SetWalkSpeed
	end
	ToggleFlight:Set(false)
end)

for i, thing in RS:GetDescendants() do
	if thing:IsA("ColorGradingEffect") then thing:Destroy() end
end

Status = Instance.new("ColorGradingEffect", RS)
Status.Name = "Status"..math.random(10000,99999)
StatusFlagType = "BoolValue"

Terminal = Instance.new("ColorGradingEffect", game.ReplicatedFirst)
Terminal.Name = "Terminal"..math.random(10000,99999)
TerminalType = "LocalScript"

local CharacterSection = MainTab:CreateSection("Character")

local ToggleForceWalkSpeed = MainTab:CreateToggle({
	Name = "Force Walk Speed",
	CurrentValue = ForceWalkSpeed,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		ForceWalkSpeed = Value
		if ForceWalkSpeed and hum then
			hum.WalkSpeed = SetWalkSpeed
		end
	end,
})

local SliderWalkSpeed = MainTab:CreateSlider({
	Name = "Set Walk Speed",
	Range = {SetWalkSpeed, 250},
	Increment = 1,
	Suffix = "",
	CurrentValue = SetWalkSpeed,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		if not hum then return end
		SetWalkSpeed = tonumber(Value)
		hum.WalkSpeed = SetWalkSpeed
	end,
})

local InputWalkSpeed = MainTab:CreateInput({
	Name = "Set Walk Speed",
	CurrentValue = SetWalkSpeed,
	PlaceholderText = "number",
	RemoveTextAfterFocusLost = true,
	Flag = "Input1",
	Callback = function(Text)
		-- The function that takes place when the input is changed
		-- The variable (Text) is a string for the value in the text box
		SetWalkSpeed = tonumber(Text)
		if not hum then return end
		hum.WalkSpeed = SetWalkSpeed
	end,
})

local DefaultGravity = game.Workspace.Gravity

local SliderGravity = MainTab:CreateSlider({
	Name = "Gravity",
	Range = {0, 500},
	Increment = 5,
	Suffix = "",
	CurrentValue = DefaultGravity,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		game.Workspace.Gravity = Value
	end,
})

local ButtonFlingSelf = MainTab:CreateButton({
	Name = "Fling Self",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not hum then return end
		if not hrp then return end
		local n1 = math.random(-2000, 3000)
		hum.Sit = true
		task.wait(0.03)
		hrp.Velocity = Vector3.new(n1,n1,n1)
	end,
})

local FlingOnTouch = false
local function loadFlingOnTouch()
	if not hrp then return end
	hrp.Touched:Connect(function(hit)
		if not FlingOnTouch then return end
		if not hit or not hit.Parent then return end
		local victimhum = hit.Parent:FindFirstChild("Humanoid")
		if not victimhum then return end
		if not hrp then return end
		local SavedAnchorState = hrp.Anchored
		task.wait(0.03)
		hrp.Anchored = true
		task.wait(0.03)
		hrp.Velocity = Vector3.new(math.random(-1000, 1000), math.random(-1000, 1000), math.random(-1000, 1000))
		task.wait(0.03)
		hrp.Anchored = SavedAnchorState
	end)
end
player.CharacterAdded:Connect(function()
	task.wait(1)
	if not hrp then return end
	loadFlingOnTouch()
end)
loadFlingOnTouch()
local ToggleFlingOnTouch = MainTab:CreateToggle({
	Name = "Fling Self On Touch",
	CurrentValue = FlingOnTouch,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		FlingOnTouch = Value
	end,
})

local ButtonSuicide = MainTab:CreateButton({
	Name = "Suicide",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not hum then return end
		hum.Health = 0
	end,
})
local SuicideSP = CFrame.new(0,0,0)
local ButtonSuicideSP = MainTab:CreateButton({
	Name = "Set Suicide SpawnPoint",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not hum then return end
		if not hrp then return end
		SuicideSP = hrp.CFrame
	end,
})
local ButtonSuicideAndGoToSP = MainTab:CreateButton({
	Name = "Suicide and go to SpawnPoint",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not hum then return end
		if not hrp then return end
		hum.Health = 0
		player.CharacterAdded:Wait()
		task.wait(0.7)
		hrp.CFrame = SuicideSP
	end,
})

local TeleportationSection = MainTab:CreateSection("Teleportion")

local TeleportationEnabled = false
local InstantTransmissionEnabled = false
local SelectedPlr = ""

local ToggleTeleportation = MainTab:CreateToggle({
	Name = "Teleportation (RMB + LBM)",
	CurrentValue = TeleportationEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		TeleportationEnabled = Value
	end,
})

local ToggleInstantTransmission = MainTab:CreateToggle({
	Name = "Instant Transmission (T)",
	CurrentValue = InstantTransmissionEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		InstantTransmissionEnabled = Value
	end,
})

local PlayerOptionsTable = {"Select"}

local DropdownTeleportToPlayer = MainTab:CreateDropdown({
	Name = "Select Player",
	Options = PlayerOptionsTable,
	CurrentOption = {"Select"},
	MultipleOptions = false,
	Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Options)
		-- The function that takes place when the selected option is changed
		-- The variable (Options) is a table of strings for the current selected options
		SelectedPlr = tostring(Options[1])
	end,
})

function ResetTpToPlrList()
	PlayerOptionsTable = {"Select"}
	for i, thing in game.Players:GetChildren() do
		if not thing:IsA("Player") then continue end
		table.insert(PlayerOptionsTable, tostring(thing.DisplayName).." (@"..tostring(thing.Name)..")")
	end
	DropdownTeleportToPlayer:Refresh(PlayerOptionsTable) -- The new list of options available.
end
ResetTpToPlrList()

game.Players.PlayerAdded:Connect(function(NewPlr)
	ResetTpToPlrList()
end)

local ButtonTeleportToPlayer = MainTab:CreateButton({
	Name = "Teleport To Player",
	Callback = function()
		-- The function that takes place when the button is pressed
		if not SelectedPlr then return end
		local GetSelectedPlr = game.Players:FindFirstChild(string.sub(string.split(SelectedPlr, "@")[2], 1, -2))
		if not GetSelectedPlr then return end
		local SelectedPlrCharacter = GetSelectedPlr.Character
		if not SelectedPlrCharacter then return end
		local SelectedPlrHumanoidRoot = SelectedPlrCharacter:FindFirstChild("HumanoidRootPart")
		if not SelectedPlrHumanoidRoot then return end
		if not char or not hrp then return end
		local pos = SelectedPlrHumanoidRoot.Position
		hrp:PivotTo(CFrame.new(pos))
		TpSound()
	end,
})

local MovementSection = MainTab:CreateSection("Movement")

function TpSound()
	if not char or not hrp then return end
	local sound = Instance.new("Sound")
	sound.Volume = 0.25
	sound.SoundId = "rbxassetid://5066021887"
	sound.PlayOnRemove = true
	sound.Parent = hrp
	sound:Destroy()
end

local UnlockMouseGuiName = "UnlockMouseTemp"

uis.InputBegan:Connect(function(input, typing)
	if typing then return end
	if not char then return end
	if not hrp then return end

	if input.KeyCode == Enum.KeyCode.V and Status then
		local tempGui = Instance.new("ScreenGui", player.PlayerGui)
		tempGui.Name = UnlockMouseGuiName
		tempGui.Enabled = true
		tempGui.ResetOnSpawn = false
		local tempButtonModal = Instance.new("TextButton", tempGui)
		tempButtonModal.Visible = true
		tempButtonModal.BackgroundTransparency = 1
		tempButtonModal.TextTransparency = 1
		tempButtonModal.Text = ""
		tempButtonModal.Modal = true
	end

	if uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) and input.UserInputType == Enum.UserInputType.MouseButton1 and TeleportationEnabled then
		local pos = mouse.Hit
		hrp:PivotTo(pos)
		TpSound()
	end

	if input.KeyCode == Enum.KeyCode.T and InstantTransmissionEnabled then
		local closestPlayer = nil
		local closestDistance = 300

		for _, plr in ipairs(game.Players:GetPlayers()) do
			if plr ~= player and (plr.Team ~= player.Team or #game.Teams:GetChildren() < 2) and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
				local distance = (hrp.Position - plr.Character.HumanoidRootPart.Position).Magnitude
				if distance < closestDistance then
					closestDistance = distance
					closestPlayer = plr
				end
			end
		end
		local targetPlr = closestPlayer
		if targetPlr and targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart") then
			local targetHrp = targetPlr.Character.HumanoidRootPart
			local direction = targetHrp.CFrame.LookVector * -2 -- Moves behind
			hrp.CFrame = targetHrp.CFrame + direction
			cam.CFrame = CFrame.lookAt(cam.CFrame.Position, targetHrp.Position)
			TpSound()
		end
	end

	if input.KeyCode == Enum.KeyCode.Space then
		local bool = Status:FindFirstChild("AirJump")
		if not bool then return end
		local savedHeight = nil
		local IsJumpPwr = hum.UseJumpPower
		local dfJump = nil
		if IsJumpPwr then
			dfJump = game.StarterPlayer.CharacterJumpPower
			savedHeight = hum.JumpPower
			hum.JumpPower = dfJump
			task.delay(0.05, function()
				hum.JumpPower = dfJump
			end)
		else
			dfJump = game.StarterPlayer.CharacterJumpHeight
			savedHeight = hum.JumpHeight
			hum.JumpHeight = dfJump
			task.delay(0.05, function()
				hum.JumpHeight = dfJump
			end)
		end
		hum:ChangeState(Enum.HumanoidStateType.Jumping)
		task.wait(0.1)
		if IsJumpPwr then
			hum.JumpPower = savedHeight or dfJump
		else
			hum.JumpHeight = savedHeight or dfJump
		end
	end
end)

uis.InputEnded:Connect(function(input, typing)
	if input.KeyCode == Enum.KeyCode.V and Status then
		local tempGui = player.PlayerGui:FindFirstChild(UnlockMouseGuiName)
		if tempGui then tempGui:Destroy() end
	end
end)

local flying = false
local flyspeed = 50

local bodyVelocity = nil

local bodyGyro = nil

local moveDirection = Vector3.new(0, 0, 0)

local function updateFlyDirection()
	if flying then
		if not bodyVelocity then
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Name = "BodyVelocityOrSomething"
			bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			bodyVelocity.Parent = hrp
		end
		if not bodyGyro then
			bodyGyro = Instance.new("BodyGyro")
			bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
			bodyGyro.P = 3000
			bodyGyro.Parent = hrp
		end
		local camera = workspace.CurrentCamera
		local direction = camera.CFrame.LookVector * moveDirection.Z + camera.CFrame.RightVector * moveDirection.X
		bodyVelocity.Velocity = direction * flyspeed + Vector3.new(0, moveDirection.Y * flyspeed, 0)
		bodyGyro.CFrame = camera.CFrame
	end
end

local function toggleFly(set)
	if set == nil then
		flying = not flying
	else
		flying = set
	end
	if flying then
		game["Run Service"].RenderStepped:Connect(updateFlyDirection)
	else
		if bodyVelocity then bodyVelocity:Destroy() end
		if bodyGyro then bodyGyro:Destroy() end
		bodyVelocity = nil
		bodyGyro = nil
	end
end

ToggleFlight = MainTab:CreateToggle({
	Name = "Flight",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		toggleFly(Value)
	end,
})

local InputFlightSpeed = MainTab:CreateInput({
	Name = "Fly Speed",
	CurrentValue = flyspeed,
	PlaceholderText = "number",
	RemoveTextAfterFocusLost = true,
	Flag = "Input1",
	Callback = function(Text)
		-- The function that takes place when the input is changed
		-- The variable (Text) is a string for the value in the text box
		flyspeed = tonumber(Text)
	end,
})

local ToggleAirJump = MainTab:CreateToggle({
	Name = "Air Jump",
	CurrentValue = false,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		if char and not Value then
			local bool = Status:FindFirstChild("AirJump")
			if bool then bool:Destroy() end
		end
		if not Value then return end
		if not char then return end
		local NewFlagVar = Instance.new(StatusFlagType, Status)
		NewFlagVar.Name = "AirJump"
	end,
})

local tp16 = uis.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.W then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, 1)
	elseif input.KeyCode == Enum.KeyCode.S then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, -1)
	elseif input.KeyCode == Enum.KeyCode.A then
		moveDirection = Vector3.new(-1, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.D then
		moveDirection = Vector3.new(1, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.E then
		moveDirection = Vector3.new(moveDirection.X, 1, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.Q then
		moveDirection = Vector3.new(moveDirection.X, -1, moveDirection.Z)
	end
end)

local tp26 = uis.InputEnded:Connect(function(input, gameProcessed)
	if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S then
		moveDirection = Vector3.new(moveDirection.X, moveDirection.Y, 0)
	elseif input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.D then
		moveDirection = Vector3.new(0, moveDirection.Y, moveDirection.Z)
	elseif input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.Q then
		moveDirection = Vector3.new(moveDirection.X, 0, moveDirection.Z)
	end
end)

local CameraSection = MainTab:CreateSection("Camera")

local AimAssistSpeed = 100  -- Smoothness for aim assist; lower values = slower movement
local AimRange = 100  -- Distance in pixels within which the aim-assist will trigger

-- Function to check if the player is in first-person
local function isFirstPerson()
	return (Camera.CFrame.Position - player.Character.Head.Position).Magnitude < 1.5 or uis.MouseBehavior == Enum.MouseBehavior.LockCenter  -- Close to player's head
end
local function aimbotkeydown()
	return aimbotToggled and aimbotenabled
end

local plrDBaim = false
local plrCDaim = 0

-- Function to find the nearest humanoid to the mouse that is visible (no walls)
local function getNearestHumanoidToMouse()
	local nearestHumanoid = nil
	local shortestDistance = (AimRange)*7.5

	for _, object in pairs(workspace:GetDescendants()) do
		if object:IsA("Humanoid") and object.Parent:FindFirstChild("HumanoidRootPart") then
			if object.Parent ~= player.Character then
				local humanoidRootPart = object.Parent:FindFirstChild("HumanoidRootPart")
				local screenPosition, onScreen = Camera:WorldToScreenPoint(humanoidRootPart.Position)

				if onScreen then
					local distanceFromMouse = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPosition.X, screenPosition.Y)).magnitude

					if distanceFromMouse < shortestDistance then
						-- Set up raycast parameters to ignore the player's character and their parts

						local raycastParams = RaycastParams.new()
						raycastParams.FilterType = Enum.RaycastFilterType.Exclude
						local table1 = {player.Character}
						--[[
						for i, part in game.Workspace:GetDescendants() do
							if not (part.Parent:FindFirstChildOfClass("Humanoid")) then
								if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("UnionOperation") then
									table.insert(table1, part)
								end
							end
							task.wait()
						end
						--]]
						raycastParams.FilterDescendantsInstances = table1

						-- Perform raycast to check for obstacles between the camera and the humanoid's root part
						local rayDirection = (humanoidRootPart.Position - Camera.CFrame.Position).unit * 1000
						local raycastResult = workspace:Raycast(Camera.CFrame.Position, rayDirection, raycastParams)

						-- If ray hits the humanoid's root part, there is no wall in the way
						if raycastResult and raycastResult.Instance:IsDescendantOf(object.Parent) then
							local plr = game.Players:GetPlayerFromCharacter(object.Parent)
							if plr then
								local plrhum = plr.Character:FindFirstChildOfClass("Humanoid")
								local plrhrp = plr.Character:FindFirstChild("HumanoidRootPart")
								if (plr.Team == player.Team and #game.Teams:GetChildren() > 1) then
									return
								end
								if not plrhum then return end
								if not plrhrp then return end
								if plrhum and plrhum.Health <= 0 then return end
								if plrhum and plrhum.Health >= 101 then return end
							end
							nearestHumanoid = object
							shortestDistance = distanceFromMouse
						end
					end
				end
			end
		end
	end

	return nearestHumanoid
end

game["Run Service"].RenderStepped:Connect(function(delta)
	if aimbotkeydown() and isFirstPerson() and not plrDBaim then  -- Only work in first-person mode
		local targetHumanoid = getNearestHumanoidToMouse()

		if targetHumanoid and targetHumanoid.Parent:FindFirstChild('HumanoidRootPart') then
			plrDBaim = false
			local head1 = targetHumanoid.Parent:FindFirstChild('Head')
			if not head1 then return end
			local targetPosition = head1.Position
			Camera = game.Workspace.CurrentCamera
			local currentPosition = Camera.CFrame.Position
			local direction = (targetPosition - currentPosition).unit

			-- Smoothly adjust the camera's CFrame to look at the target
			local newCFrame = CFrame.new(currentPosition, currentPosition + direction)
			if AimAssistSpeed <= 0 then
				Camera.CFrame = newCFrame
			else
				Camera.CFrame = Camera.CFrame:Lerp(newCFrame, ((AimAssistSpeed * 20)/100)*delta)
			end
			--task.wait(plrCDaim)
			plrDBaim = false
		end
	end
end)

aimbotToggled = false
aimbotenabled = false
aimbotkey = Enum.UserInputType.MouseButton2
local tp1234 = uis.InputBegan:Connect(function(input, typing)
	if input.UserInputType == aimbotkey and aimbotToggled then
		aimbotenabled = true
	end
end)
local tp2234 = uis.InputEnded:Connect(function(input, typing)
	if input.UserInputType == aimbotkey then
		aimbotenabled = false
	end
end)

ToggleAimBot = MainTab:CreateToggle({
	Name = "Aim bot- i mean assist (RMB)",
	CurrentValue = aimbotToggled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		aimbotToggled = Value
	end,
})

local SliderAimBotSpeed = MainTab:CreateSlider({
	Name = "Aim Bot Speed (0 for instant snapping)",
	Range = {0, 250},
	Increment = 10,
	Suffix = "",
	CurrentValue = AimAssistSpeed,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		AimAssistSpeed = tonumber(Value) or 0
	end,
})

local SliderAimBotRange = MainTab:CreateSlider({
	Name = "Aim Bot Range (100 is your whole screen)",
	Range = {10, 100},
	Increment = 10,
	Suffix = "",
	CurrentValue = AimRange,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the slider changes
		-- The variable (Value) is a number which correlates to the value the slider is currently at
		AimAssistSpeed = tonumber(Value) or 100
	end,
})

local ButtonAllowShiftlock = MainTab:CreateButton({
	Name = "Allow Shiftlock",
	Callback = function()
		-- The function that takes place when the button is pressed
		if player.DevEnableMouseLock then
			Rayfield:Notify({
				Title = "...",
				Content = "Shiftlock is already allowed",
				Duration = 2.5,
				Image = "shield-alert",
			})
		end
		player.DevEnableMouseLock = true
	end,
})

local TerminalTab = Window:CreateTab("Terminal", "terminal") -- Title, Image
local TerminalSource = 'print("Hello world!")'
TerminalTab:CreateSection("Default variables: player, char, hum, hrp, head, cam")

local InputTerminal = TerminalTab:CreateInput({
	Name = "Source",
	CurrentValue = TerminalSource,
	PlaceholderText = "...",
	RemoveTextAfterFocusLost = false,
	Flag = "Input1",
	Callback = function(Text)
		-- The function that takes place when the input is changed
		-- The variable (Text) is a string for the value in the text box
		TerminalSource = tostring(Text)
	end,
})

local ButtonExecuteTerminal = TerminalTab:CreateButton({
	Name = "Execute",
	Callback = function()
		-- The function that takes place when the button is pressed
		local ran, broke = pcall(function()
			return loadstring(TerminalSource)()
		end)
		if ran then
			Rayfield:Notify({
				Title = "Success",
				Content = "Executed source / " .. TerminalType,
				Duration = 6.5,
				Image = "shield-check",
			})
		else
			warn(broke)
			broke = string.split(broke, ":")
			local brokeLine = tostring((tonumber(broke[2] or broke[1]) or 0)-698)
			if tonumber(brokeLine) <= 0 then brokeLine = "?" end
			broke = broke[3] or broke[2] or "Error" .. " / line: " .. brokeLine
			broke = tostring(broke)
			Rayfield:Notify({
				Title = "Error",
				Content = "Error Code / " .. broke,
				Duration = 6.5,
				Image = "shield-x",
			})
			warn(broke)
		end
	end,
})

local TheStrongestBattlegroundsTab = Window:CreateTab("The Strongest Battlegrounds", nil) -- Title, Image
local SgbAnimPriorities = Enum.AnimationPriority.Action4
local ReloadAnimsWait = 1

local animations = {
	{
		Section = "KJ Animations",
		Name = "Ultimate 1",
		ID = 17140902079,
	},
	{
		Name = "Ultimate 2",
		ID = 18445236460,
	},
	{
		Name = "Stoic Bomb",
		ID = 17141153099,
	},
	{
		Name = "20-20-20 Dropkick Use",
		ID = 17354976067,
	},
	{
		Name = "20-20-20 Dropkick Hit",
		ID = 17420452843,
	},
	{
		Name = "Collateral Ruin",
		ID = 17325254223,
	},
	{
		Name = "Ultimate Flex Works",
		ID = 77727115892579,
	},
	{
		Section = "Saitama Animations",
		Name = "Ultimate",
		ID = 12447707844,
	},
	{
		Name = "Omni Directional Punch",
		ID = 13927612951,
	},
	{
		Name = "Serious Punch",
		ID = 12983333733,
	},
	{
		Name = "Table Flip",
		ID = 11365563255,
	},
	{
		Section = "Hero Hunter Animations",
		Name = "Ultimate",
		ID = 12342141464,
	},
	{
		Name = "Water Stream Cutting Fist",
		ID = 12460977270,
	},
	{
		Name = "Final Hunt Use",
		ID = 12463072679,
	},
	{
		Name = "Final Hunt Hit",
		ID = 12467789963,
	},
	{
		Name = "Rock Splitting Fist",
		ID = 14057231976,
	},
	{
		Name = "Crushed Rock Use",
		ID = 13630786846,
	},
	{
		Name = "Crushed Rock Hit",
		ID = 13813099821,
	},
	{
		Section = "Destructive Cyborg Animations",
		Name = "Ultimate",
		ID = 12772543293,
	},
	{
		Name = "Speed Blitz Dropkick",
		ID = 12832505612,
	},
	{
		Name = "Flamewave Canon",
		ID = 13083332742,
	},
	{
		Name = "Incinerate",
		ID = 13146710762,
	},
	{
		Section = "Deadly Ninja Animations",
		Name = "Ultimate",
		ID = 13499771836,
	},
	{
		Name = "Twinblade Rush Use",
		ID = 13632347366,
	},
	{
		Name = "Twinblade Rush Hit",
		ID = 13633468484,
	},
	{
		Name = "Straight On",
		ID = 13643152947,
	},
	{
		Name = "Carnage",
		ID = 13723174078,
	},
	{
		Name = "Fourfold Flashstrike",
		ID = 13881335713,
	},
	{
		Section = "Brutal Demon Animations",
		Name = "Ultimate",
		ID = 14733282425,
	},
	{
		Name = "Death Blow Use",
		ID = 15128849047,
	},
	{
		Name = "Death Blow Counter",
		ID = 15123665491,
	},
	{
		Name = "Savage Tornado",
		ID = 14719290328,
	},
	{
		Name = "Brutal Beatdown",
		ID = 14701242661,
	},
	{
		Name = "Strength Difference Use",
		ID = 14900168720,
	},
	{
		Name = "Strength Difference Hit",
		ID = 14920779925,
	},
	{
		Section = "Blade Master Animations",
		Name = "Ultimate",
		ID = 15391323441,
	},
	{
		Name = "Sunset",
		ID = 15520132233,
	},
	{
		Name = "Solar Cleave",
		ID = 15676072469,
	},
	{
		Name = "Sun Rise Use",
		ID = 16062410809,
	},
	{
		Name = "Sun Rise Hit",
		ID = 16062712948,
	},
	{
		Name = "Atomic Slash Use",
		ID = 16082123712,
	},
	{
		Name = "Atomic Slash Hit",
		ID = 16057411888,
	},
	{
		Section = "Wild Psychic Animations",
		Name = "Ultimate",
		ID = 16734584478,
	},
	{
		Name = "Cosmic Strike",
		ID = 16737255386,
	},
	{
		Name = "Psychic Ricochet",
		ID = 17464644182,
	},
	{
		Name = "Terrible Tornado",
		ID = 17278415853,
	},
	{
		Name = "Sky Snatcher Use",
		ID = 17860467628,
	},
	{
		Name = "Sky Snatcher Hit",
		ID = 17889080495,
	},
	{
		Section = "Martial Artist Animations",
		Name = "Ultimate (goofy)",
		ID = 18435535291,
	},
	{
		Name = "Grand Fissure",
		ID = 129651400898906,
	},
	{
		Name = "Twin Fangs",
		ID = 18896229321,
	},
	{
		Name = "Earth Splitting Strike Use",
		ID = 18897119503,
	},
	{
		Name = "Earth Splitting Strike Hit",
		ID = 18897118507,
	},
	{
		Name = "Last Breath Use",
		ID = 106755459092436,
	},
	{
		Name = "Last Breath Hit",
		ID = 75502010126640,
	},
	{
		Section = "The Frozen Soul Animations",
		Name = "Equip",
		ID = 95000469063288,
	},
	{
		Name = "Ultimate: Sub-Zero Slash Storm",
		ID = 134494086123052,
	},
	{
		Name = "Permafrost",
		ID = 100558589307006,
	},
	{
		Name = "Frost Forge",
		ID = 137561511768861,
	},
	{
		Name = "Freezing Path",
		ID = 112620365240235,
	},
	{
		Name = "Judgement Chain",
		ID = 75547590335774,
	},
}

local function createAnimationToggle(animation)
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. animation.ID
	local loadedAnim = hum:LoadAnimation(anim)
	loadedAnim.Looped = false
	loadedAnim.Priority = SgbAnimPriorities

	local toggle = TheStrongestBattlegroundsTab:CreateToggle({
		Name = animation.Name,
		CurrentValue = false,
		Flag = "AnimToggle",
		Callback = function(Value)
			if Value then
				loadedAnim:Play()
			else
				loadedAnim:Stop()
			end
		end
	})

	loadedAnim.Ended:Connect(function()
		toggle:Set(false)
	end)

	player.CharacterAdded:Connect(function()
		task.wait(ReloadAnimsWait)
		anim = Instance.new("Animation")
		anim.AnimationId = "rbxassetid://" .. animation.ID
		loadedAnim = hum:LoadAnimation(anim)
		loadedAnim.Looped = false
		loadedAnim.Priority = SgbAnimPriorities
		loadedAnim.Ended:Connect(function()
			toggle:Set(false)
		end)
	end)
end

local lastSection = nil
for _, animation in ipairs(animations) do
	if animation.Section and animation.Section ~= lastSection then
		TheStrongestBattlegroundsTab:CreateSection(animation.Section)
		lastSection = animation.Section
	end
	createAnimationToggle(animation)
end

local BuildABoatForTreasureTab = Window:CreateTab("Build A Boat For Treasure", nil) -- Title, Image

local BabAutoWinEnabled = false

local ToggleBabAutoWin = BuildABoatForTreasureTab:CreateToggle({
	Name = "Auto Farm",
	CurrentValue = InstantTransmissionEnabled,
	Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		-- The function that takes place when the toggle is pressed
		-- The variable (Value) is a boolean on whether the toggle is true or false
		BabAutoWinEnabled = Value
		task.spawn(function()
			while BabAutoWinEnabled do
				hrp.Velocity = Vector3.new(0,0,0)
				task.wait(0.03)
			end
		end)
		while BabAutoWinEnabled do
			task.wait(0.5)
			if not hrp then continue end
			hrp.Anchored = false
			local SmoothTweenEasingStyle = Enum.EasingStyle.Quad
			local InitialPos = game.TweenService:Create(hrp, TweenInfo.new(1, SmoothTweenEasingStyle), {CFrame = CFrame.new(-51.4020881652832, 42.1522228717803955, 232.0143127441406, 1, 2.8233428e-08, 0.000197172689, -2.82372294e-08, 1, 1.92742942e-08, -0.000197172689, -1.92798613e-08, 1)})
			InitialPos:Play()
			InitialPos.Completed:Wait()
			local FlyToWaterFall = game.TweenService:Create(hrp, TweenInfo.new(23, SmoothTweenEasingStyle), {CFrame = CFrame.new(-20.47932815551758, 65.726470947265625, 8652.3564453125, -0.322770327, 4.80723372e-08, 0.946477294, -2.44336444e-08, 1, -5.91232272e-08, -0.946477294, -4.22091126e-08, -0.322770327)})
			FlyToWaterFall:Play()
			FlyToWaterFall.Completed:Wait()
			local FlyDownWaterFall = game.TweenService:Create(hrp, TweenInfo.new(1.2, SmoothTweenEasingStyle), {CFrame = CFrame.new(-47.588069915771484, -336.2562561035156, 8662.7421875, -0.992341876, -1.69527556e-08, -0.123521589, -2.45594425e-08, 1, 6.00591932e-08, 0.123521589, 6.26328784e-08, -0.992341876)})
			FlyDownWaterFall:Play()
			FlyDownWaterFall.Completed:Wait()
			local FlyToTreasure = game.TweenService:Create(hrp, TweenInfo.new(2.5, SmoothTweenEasingStyle), {CFrame = CFrame.new(-55.87642288208008, -360.52899169921875, 9489.6767578125, -0.322770327, 4.80723372e-08, 0.946477294, -2.44336444e-08, 1, -5.91232272e-08, -0.946477294, -4.22091126e-08, -0.322770327)})
			FlyToTreasure:Play()
			FlyToTreasure.Completed:Wait()
			hrp.Anchored = true
			task.wait(1.2)
			local FlyToTreasure2 = game.TweenService:Create(hrp, TweenInfo.new(3, SmoothTweenEasingStyle), {CFrame = CFrame.new(-55.87642288208008, -360.52899169921875, 9490.6767578125, -0.866842806, -2.4441368e-08, -0.498581529, -2.98235392e-08, 1, 2.82993073e-09, 0.498581529, 1.732257e-08, -0.866842806)})
			FlyToTreasure2:Play()
			FlyToTreasure2.Completed:Wait()
			task.wait(2)
			hrp.Anchored = false
			task.wait(18)
		end
	end,
})
